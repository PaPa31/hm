"use strict";(self.webpackChunkhuman_and_machine=self.webpackChunkhuman_and_machine||[]).push([[47235],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return u}});var o=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,o,i=function(e,t){if(null==e)return{};var a,o,i={},n=Object.keys(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=o.createContext({}),p=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},h=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),c=p(a),u=i,d=c["".concat(l,".").concat(u)]||c[u]||m[u]||n;return a?o.createElement(d,r(r({ref:t},h),{},{components:a})):o.createElement(d,r({ref:t},h))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,r=new Array(n);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<n;p++)r[p]=a[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,a)}c.displayName="MDXCreateElement"},80709:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return h},default:function(){return c}});var o=a(87462),i=a(63366),n=(a(67294),a(3905)),r=["components"],s={id:"git-best-practicies",title:"Commit Often, Perfect Later, Publish Once: Git Best Practices",sidebar_label:"Git Best Practicies"},l=void 0,p={unversionedId:"workplace/git/git-best-practicies",id:"workplace/git/git-best-practicies",isDocsHomePage:!1,title:"Commit Often, Perfect Later, Publish Once: Git Best Practices",description:"Best Practices vary from environment to environment, and there is no One True Answer, but still, this represents a consensus from #git and in some cases helps you frame the discussion for the generation of your very own best practices.",source:"@site/docs/workplace/git/git-best-practicies.md",sourceDirName:"workplace/git",slug:"/workplace/git/git-best-practicies",permalink:"/hm/docs/workplace/git/git-best-practicies",editUrl:"https://github.com/papa31/hm/edit/documentation/docs/workplace/git/git-best-practicies.md",tags:[],version:"current",lastUpdatedBy:"papa",lastUpdatedAt:1607092324,formattedLastUpdatedAt:"12/4/2020",frontMatter:{id:"git-best-practicies",title:"Commit Often, Perfect Later, Publish Once: Git Best Practices",sidebar_label:"Git Best Practicies"},sidebar:"Docs",previous:{title:"Download One Github Folder",permalink:"/hm/docs/workplace/git/download-one-github-folder"},next:{title:"Git Workflow",permalink:"/hm/docs/workplace/git/git-workflow"}},h=[{value:"Do read about git",id:"do-read-about-git",children:[]},{value:"Do commit early and often",id:"do-commit-early-and-often",children:[]},{value:"Don\u2019t panic",id:"dont-panic",children:[]},{value:"Do backups",id:"do-backups",children:[]},{value:"Don\u2019t change published history",id:"dont-change-published-history",children:[]},{value:"Do choose a workflow",id:"do-choose-a-workflow",children:[{value:"Branch workflows",id:"branch-workflows",children:[]},{value:"Distributed workflows",id:"distributed-workflows",children:[]},{value:"Release tagging",id:"release-tagging",children:[]},{value:"Security model",id:"security-model",children:[]}]},{value:"Do divide work into repositories",id:"do-divide-work-into-repositories",children:[]},{value:"Do make useful commit messages",id:"do-make-useful-commit-messages",children:[]},{value:"On Sausage Making",id:"on-sausage-making",children:[]},{value:"Do keep up to date",id:"do-keep-up-to-date",children:[]},{value:"Do periodic maintenance",id:"do-periodic-maintenance",children:[]},{value:"Do enforce standards",id:"do-enforce-standards",children:[]},{value:"Do use useful tools",id:"do-use-useful-tools",children:[]},{value:"Do integrate with external tools",id:"do-integrate-with-external-tools",children:[]},{value:"Miscellaneous \u201cDo\u201ds",id:"miscellaneous-dos",children:[]},{value:"Miscellaneous \u201cdon\u2019t\u201ds",id:"miscellaneous-donts",children:[]},{value:"Disclaimer",id:"disclaimer",children:[]},{value:"Copyright",id:"copyright",children:[]},{value:"Thanks",id:"thanks",children:[]},{value:"Comments",id:"comments",children:[]}],m={toc:h};function c(e){var t=e.components,a=(0,i.Z)(e,r);return(0,n.kt)("wrapper",(0,o.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Best Practices vary from environment to environment, and there is no One True Answer, but still, this represents a consensus from #git and in some cases helps you frame the discussion for the generation of your very own best practices."),(0,n.kt)("h2",{id:"do-read-about-git"},"Do read about git"),(0,n.kt)("p",null,"Knowing where to look is half the battle. I strongly urge everyone to read (and support) the Pro Git book. The other resources are highly recommended by various people as well."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://git-scm.com/book/"},"Pro Git")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://eagain.net/articles/git-for-computer-scientists/"},"Git for Computer Scientists")," and a ",(0,n.kt)("a",{parentName:"li",href:"http://sitaramc.github.com/gcs/"},"different/updated version")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://jwiegley.github.io/git-from-the-bottom-up/"},"Git from the Bottom Up")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://tom.preston-werner.com/2009/05/19/the-git-parable.html"},"The Git Parable")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://git-scm.com/documentation"},"Other resources")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://git.wiki.kernel.org/"},"Git wiki"))),(0,n.kt)("h2",{id:"do-commit-early-and-often"},"Do commit early and often"),(0,n.kt)("p",null,"Git only takes full responsibility for your data when you commit. If you fail to commit and then do something poorly thought out, you can run into trouble. Additionally, having periodic checkpoints means that you can understand how you broke something."),(0,n.kt)("p",null,"People resist this out of some sense that this is ugly, limits ",(0,n.kt)("inlineCode",{parentName:"p"},"git-bisect"),"ion functionality, is confusing to observers, and might lead to accusations of stupidity. Well, I\u2019m here to tell you that resisting this is ignorant. ",(0,n.kt)("em",{parentName:"p"},"Commit Early And Often"),". If, after you are done, you want to pretend to the outside world that your work sprung complete from your mind into the repository in utter perfection with each concept fully thought out and divided into individual concept-commits, well git supports that: see ",(0,n.kt)("a",{parentName:"p",href:"#on-sausage-making"},"Sausage Making")," below. However, don\u2019t let tomorrow\u2019s beauty stop you from performing continuous commits today."),(0,n.kt)("p",null,"Personally, I commit early and often and then let the sausage making be seen by all except in the most formal of circumstances (public projects with large numbers of users, developers, or high developer turnover). For a less formal usage, ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/SethRobertson/GitBestPractices/commits/gh-pages"},"like say this document")," I let people see what really happened."),(0,n.kt)("h2",{id:"dont-panic"},"Don\u2019t panic"),(0,n.kt)("p",null,"As long as you have committed your work (or in many cases even added it with ",(0,n.kt)("inlineCode",{parentName:"p"},"git add"),") your work will not be lost for at least two weeks unless you really work at it (run commands that manually purge it)."),(0,n.kt)("p",null,"See ",(0,n.kt)("a",{parentName:"p",href:"http://sethrobertson.github.com/GitFixUm/"},"on undoing, fixing, or removing commits in git")," if you want to fix a particular problematic commit or commits, as opposed to attempting to locate lost data."),(0,n.kt)("p",null,"When attempting to find your lost commits, first make ",(0,n.kt)("em",{parentName:"p"},"sure")," you will not lose any current work. You should commit or stash your current work before performing any recovery efforts that might destroy your current work and perhaps take backups of it (see ",(0,n.kt)("a",{parentName:"p",href:"#do-backups"},"Backups")," below). After finding the commits you can ",(0,n.kt)("inlineCode",{parentName:"p"},"reset"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"rebase"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"cherry-pick"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"merge"),", or otherwise do what is necessary to get the commit history and work tree you desire."),(0,n.kt)("p",null,"There are three places where \u201clost\u201d changes can be hiding. They might be in the reflog (",(0,n.kt)("inlineCode",{parentName:"p"},"git log -g"),"), they might be in lost&found (",(0,n.kt)("inlineCode",{parentName:"p"},"git fsck --unreachable"),"), or they might have been stashed (",(0,n.kt)("inlineCode",{parentName:"p"},"git stash list"),")."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"reflog"),(0,n.kt)("p",{parentName:"li"},"The reflog is where you should look first and by default. It shows you each commit that modified the git repository. You can use it to find the commit name (SHA-1) of the state of the repository before (and after) you typed that command. While you are free to go through the reflog manually (",(0,n.kt)("inlineCode",{parentName:"p"},"git log -g"),") or searching it (",(0,n.kt)("inlineCode",{parentName:"p"},"git log -Sfoo -g"),"), you can also visualize the repository using the following command (Look for dots without children and without green labels):"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"gitk --all --date-order $(git log -g --pretty=%H) \n"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Lost and found"),(0,n.kt)("p",{parentName:"li"},"Commits or other git data that are no longer reachable through any reference name (branch, tag, etc) are called \u201cdangling\u201d and may be found using ",(0,n.kt)("inlineCode",{parentName:"p"},"fsck"),". There are legitimate reasons why objects may be dangling through standard actions and normally over 99% of them are entirely uninteresting for this reason."),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Dangling Commit"),(0,n.kt)("p",{parentName:"li"},"These are the most likely candidates for finding lost data. A dangling commit is a commit no longer reachable by any branch or tag. This can happen due to resets and rebases and are normal. ",(0,n.kt)("inlineCode",{parentName:"p"},"git show SHA-1")," will let you inspect them."),(0,n.kt)("p",{parentName:"li"},"The following command helps you visualize these dangling commits. Look for dots without children and without green labels."),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"gitk --all --date-order $(git fsck | grep \"dangling commit\" | awk '{print $3;}') \n"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Dangling Blob"),(0,n.kt)("p",{parentName:"li"},"A dangling blob is a file that was not attached to a commit. This is often caused by ",(0,n.kt)("inlineCode",{parentName:"p"},"git add"),"s that were superceded before commit or merge conflicts. Inspect these files with"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"git show SHA-1 \n"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Dangling Tree"),(0,n.kt)("p",{parentName:"li"},"A dangling tree is a directory tree of files that was not attached to a commit. These are rarely interesting, and often caused by merge conflicts. Inspect these files with ",(0,n.kt)("inlineCode",{parentName:"p"},"git ls-tree -r SHA-1"))))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Stashes"),(0,n.kt)("p",{parentName:"li"},"Finally, you may have stashed the data instead of committing it and then forgotten about it. You can use the ",(0,n.kt)("inlineCode",{parentName:"p"},"git stash list")," command or inspect them visually using:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"gitk --all --date-order $(git stash list | awk -F: '{print $1};') \n"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Misplaced"),(0,n.kt)("p",{parentName:"li"},"Another option is that your commit is not lost. Perhaps the commit was just made on a different branch from what you remember. Using ",(0,n.kt)("inlineCode",{parentName:"p"},"git log -Sfoo --all")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"gitk --all --date-order")," to try and hunt for your commits on known branches.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Look elsewhere"),(0,n.kt)("p",{parentName:"li"},"Finally, you should check your backups, testing copies, ask the other people who have a copy of the repo, and look in other repos."))),(0,n.kt)("h2",{id:"do-backups"},"Do backups"),(0,n.kt)("p",null,"Everyone always recommends taking backups as best practice, and I am going to do the same. However, you already may have a highly redundant distributed ad-hoc backup system in place! This is because essentially every clone is a backup. In many cases, you may want to use a clone for git experiments to perfect your method before trying it for real (this is most useful for ",(0,n.kt)("inlineCode",{parentName:"p"},"git filter-branch")," and similar commands where your goal is to permanently destroy history without recourse\u2014if you mess it up you may not have recourse). Still, probably you need a more formal system as well."),(0,n.kt)("p",null,"Traditional backups are still appropriate, and clones do not save git configurations, the working directory and index, non-standard refs, or dangling objects anyway. A normal tarball, ",(0,n.kt)("inlineCode",{parentName:"p"},"cp"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"rsync"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"zip"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"rar")," or similar backup copy will be a perfectly fine backup. As long as the underlying filesystem doesn\u2019t reorder git I/O dramatically and there is not a long time delay between the scanning of the directory and the retrieval of the files, the resulting copy of ",(0,n.kt)("inlineCode",{parentName:"p"},".git")," should be consistent under almost all circumstances including if taken while git operations are in progress, though you might have to do some recovery\u2013the data will all be present. See also ",(0,n.kt)("a",{parentName:"p",href:"http://marc.info/?l=git&m=136422341014631&w=2"},"discussions about custom backup techniques to ensure git consistency"),"\u2013though it does not mention ",(0,n.kt)("inlineCode",{parentName:"p"},"git bundle create ... --all")," which appears to be the only atomic native git command that can create a backup. When performing git experiments involving items other than normally reachable commits, a copy instead of a clone may be more appropriate."),(0,n.kt)("p",null,"However, if you want a \u201cpure git\u201d solution that clones everything in a directory of repos, something like this may be what you need:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"cd /src/backupgit\nls -F . | grep / > /tmp/.gitmissing1\nssh -n git.example.com ls -F /src/git/. | grep / > /tmp/.gitmissing2\ndiff /tmp/.gitmissing1 /tmp/.gitmissing2 | egrep '^>' |\nwhile read x f; do\n    git clone --bare --mirror ssh://git.example.com/src/git/$$f $$f\ndone\nrm -f /tmp/.gitmissing1 /tmp/.gitmissing2\nfor f in */.; do (cd $$f; echo $$f; git fetch); done\n")),(0,n.kt)("h2",{id:"dont-change-published-history"},"Don\u2019t change published history"),(0,n.kt)("p",null,"Once you ",(0,n.kt)("inlineCode",{parentName:"p"},"git push")," (or in theory someone pulls from your repo, but people who pull from a working repo often deserve what they get) your changes to the authoritative upstream repository or otherwise make the commits or tags publicly visible, you should ideally consider those commits etched in diamond for all eternity. If you later find out that you messed up, make new commits that fix the problems (possibly by revert, possibly by patching, etc)."),(0,n.kt)("p",null,"Yes, of course git allows you to rewrite public history, but it is problematic for everyone and thus it is just not best practice to do so."),(0,n.kt)("p",null,"I\u2019ve said it and I believe it, but\u2026on occasion\u2026if well managed\u2026there are times when changing published history is perhaps a normal course of business. You can plan for particular branches (integration branches especially) or (better) special alternate repositories to be continually rewritten as a matter of course. You see this in git.git with the \u201cpu\u201d branch, for example. Obviously this process must be well controlled and ideally done by one of the most experienced and well trusted engineers (because auditing merges (and worse, non-merge commits) you have essentially seen before is extremely tedious, boring, and error prone and you have lost the protection of git\u2019s cryptographic history validation)."),(0,n.kt)("h2",{id:"do-choose-a-workflow"},"Do choose a workflow"),(0,n.kt)("p",null,"Some people have called git a tool to create a SCM workflow instead of an SCM tool. There is some truth to this. I am not going to specifically espouse one specific workflow as the best practice for using git since it depends heavily on the size and type of project and the skill of users, developers, and release engineers; however both reflexive avoidance of branches due to stupidity of other SCM systems and reflexive overuse of branches (since branches are actually easy with git) is most likely ignorance. Pick the style that best suits your project and don\u2019t complain about user\u2019s tactical uses of private branches."),(0,n.kt)("p",null,"I also implore managers who may be thinking of making specific workflow rules by fiat to remember that not all projects are identical, and rules that work on one project may not work on another. People who blather on about continuous integration, rolling deployment, and entirely independent feature changes that you can pick and choose between independently are absolutely correct, ",(0,n.kt)("em",{parentName:"p"},"for their project!")," However, there are many projects and features which are much more complicated and may take longer than a particular sprint/unit-of-time and require multiple people to complete and have complex interdependencies with other features. It is not a sign of stupidity but rather of complexity and, just perhaps, brilliant developers, who can keep it all straight. It can also lead to a market advantage since you can deploy a differentiating feature which your competitors cannot in a short timeframe."),(0,n.kt)("h3",{id:"branch-workflows"},"Branch workflows"),(0,n.kt)("p",null,"Answering the following questions helps you choose a branch workflow:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Where do important phases of development occur?"),(0,n.kt)("li",{parentName:"ul"},"How can you identify (and backport) groups of related change?"),(0,n.kt)("li",{parentName:"ul"},"Do you have work which often needs to be updated in multiple distinct long-lived branches?"),(0,n.kt)("li",{parentName:"ul"},"What happens when emergency patches are required?"),(0,n.kt)("li",{parentName:"ul"},"What should a branch for a particular purpose (including user-tactical) be named?"),(0,n.kt)("li",{parentName:"ul"},"What is the lifecycle of a branch?")),(0,n.kt)("p",null,"See the following references for more information on branch workflows."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://git-scm.com/book/ch3-4.html"},"Pro Git branching models")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://nvie.com/posts/a-successful-git-branching-model/"},"Git-flow branching model")," (with ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/petervanderdoes/gitflow-avh"},"the associated gitflow tool"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://jk.gs/gitworkflows.html"},"Gitworkflows man page")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://reinh.com/blog/2009/03/02/a-git-workflow-for-agile-teams.html"},"A Git Workflow for Agile Teams")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://stackoverflow.com/questions/2621610/what-git-branching-models-actually-work"},"What git branching models actually work")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://web.archive.org/web/20150405004638/http://blogs.remobjects.com/blogs/mh/2011/08/25/p2940"},"Our New Git Branching Model")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://dymitruk.com/blog/2012/02/05/branch-per-feature/"},"Branch-per-Feature")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://widgetsandshit.com/teddziuba/2011/12/process.html"},"Who Needs Process"))),(0,n.kt)("p",null,"However, also understand that everyone already has an implicit private branch due to their cloned repository: they can do work locally, do a ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull --rebase")," when they are done, perform final testing, and then push their work out. If you run into a situation where you might need the benefits of a feature branch before you are done, you can even retroactively commit&branch then optionally reset your primary branch back to @{u}. Once you push you lose that ability."),(0,n.kt)("p",null,"Some people have been very successful with just master and $RELEASE branches ($RELEASE branch for QA and polishing, master for features, specific to each released version.) Other people have been very successful with many feature branches, integration branches, QA, and release branches. The faster the release cycle and the more experimental the changes, the more branches will be useful\u2014continuous releases or large refactoring project seem to suggest larger numbers of branches (note the number of branches is the tail, not the dog: more branches will not make you release faster)."),(0,n.kt)("p",null,"The importance of some of the questions I asked may not be immediately obvious. For example, how does having work which needs to be updated in multiple distinct long-lived branches affect branch workflow? Well, you may want to try to have a \u201ccore\u201d branch which these other branches diverge from, and then have your feature/bugfix branches involving these multiple branches come off of the lowest-common-merge-base (LCMB) for these long-lived branches. This way, you make your change (potentially merge your feature branch back into the \u201ccore\u201d branch), and then merge the \u201ccore\u201d branch back into all of the other long-lived branches. This avoids the dreaded cherry-pick workflow."),(0,n.kt)("p",null,"Branch naming conventions are also often overlooked. You must have conventions for naming release branches, integration branches, QA branches, feature branches (if applicable), tactical branches, team branches, user branches, etc. Also, if you use share repositories with other projects/groups, you probably will need a way to disambiguate your branches from their branches. Don\u2019t be afraid of \u201c/\u201d in the branch name when appropriate (but do be afraid of using a remote\u2019s name as a directory component of a branch name, or correspondingly naming a remote after a branch name or directory component)."),(0,n.kt)("h3",{id:"distributed-workflows"},"Distributed workflows"),(0,n.kt)("p",null,"Answering the following questions helps you choose a distributed workflow:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Who is allowed to publish to the master repository?"),(0,n.kt)("li",{parentName:"ul"},"What is the process between a developer finishing coding and the code being released to the end-user?"),(0,n.kt)("li",{parentName:"ul"},"Are there distinct groups that work on distinct sections of the codebase and only integrate at epochs? (Outsourcing)"),(0,n.kt)("li",{parentName:"ul"},"Is everyone inside the same administrative domain?")),(0,n.kt)("p",null,"See the following references for more information on distributed workflows."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://web.archive.org/web/20160314124550/http://git-scm.com/book/ch5-1.html"},"Pro Git distributed models")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://jk.gs/gitworkflows.html"},"Gitworkflows man page"))),(0,n.kt)("p",null,"Cathedrals (traditional corporate development models) often want to have (or to pretend to have) the one true centralized repository. Bazaars (linux, and the Github-promoted workflow) often want to have many repositories with some method to notify a higher authority that you have work to integrate (pull requests)."),(0,n.kt)("p",null,"However, even if you go for, say, a traditional corporate centralized development model, don\u2019t forbid self-organized teams to create their own repositories for their own tactical reasons. Even having to fill out a justification form is probably too cumbersome."),(0,n.kt)("h3",{id:"release-tagging"},"Release tagging"),(0,n.kt)("p",null,"Choosing your release workflow (how to get the code to the customer) is another important decision. You should have already considered most of the issues when going over the branching and distributed workflow above, but less obviously, it may affect how and when you perform tagging, and specifically the name of the tag you use."),(0,n.kt)("p",null,"At first glance, it is a no-brainer. When you release something you tag something, and of course I ",(0,n.kt)("em",{parentName:"p"},"highly")," recommend this. However, tags should be treated as immutable once you push. Well, that only makes sense, you might think to yourself, but consider this: five minutes after everyone has signed off on the 2.0 release, it has been tagged ",(0,n.kt)("inlineCode",{parentName:"p"},"Frobber_Release_2.0")," and pushed, but before any customer has seen the resulting product someone comes running in \u201cOMFG, the foobar is broken when you frobnoz the baz.\u201d What do you do? Do you skip release ",(0,n.kt)("inlineCode",{parentName:"p"},"2.0")," and tag ",(0,n.kt)("inlineCode",{parentName:"p"},"2.0.1"),"? Do you do a take-back and go to every repo of every developer and delete the ",(0,n.kt)("inlineCode",{parentName:"p"},"2.0")," tag?"),(0,n.kt)("p",null,"Two ideas for your consideration. Instead of a release tag, use a release branch with the marketing name (and then stop committing to that branch after release, disabling write access to it in ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/sitaramc/gitolite"},"gitolite")," or something). Another idea, use an internal tag name that is not directly derived from the version number that marketing wishes to declare to the outside world. The problem with the branch idea is that if you cannot (or forget to) disable write access then someone might accidentally commit to that branch, leading to confusion about what was actually released to the customer. The problem with the tag idea is that you need to remember what the final shipped tag name is, independent from the release name. However, if you use both techniques, they cover for each other\u2019s disadvantages. In any case, using either technique will be better than using marketing-version tags (as I know from experience)."),(0,n.kt)("h3",{id:"security-model"},"Security model"),(0,n.kt)("p",null,"You might ask why security is not a top level item and is near the end of the workflow section. Well that is because in an ideal world your security should support your workflow not be an impediment to it."),(0,n.kt)("p",null,"For instance, did you decide certain branches should only have certain people being allowed to access it? Did you decide that certain repositories should only have certain people able to access/write to them?"),(0,n.kt)("p",null,"While git allows users to set up many different types of access control, access methods, and the like; the best for most deployments might be to set up a centralized git master repository with a ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/sitaramc/gitolite"},"gitolite")," manager to provide fine grained access control with ssh based authentication and encryption."),(0,n.kt)("p",null,"Of course, security is more than access control. It is also assurance that what you release is what was written by the people it should be written by, and what was tested. Git provides you this for free, but certain formal users may wish to use signed tags. Watch for signed pushes in a future version of git."),(0,n.kt)("h2",{id:"do-divide-work-into-repositories"},"Do divide work into repositories"),(0,n.kt)("p",null,"Repositories sometimes get used to store things that they should not, simply because they were there. Try to avoid doing so."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"One conceptual group per repository"),(0,n.kt)("p",{parentName:"li"},"Does this mean one per product, program, library, class? Only you can say. However, dividing stuff up later is annoying and leads to rewriting public history or duplicative or missing history. Dividing it up correctly beforehand is much better.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Read access control is at the repo level"),(0,n.kt)("p",{parentName:"li"},"If someone has access to a repository, they have access to the entire repo, all branches, all history, everything. If you need to compartmentalize read access, separate the compartments into different repositories.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Separate repositories for files that might be needed by multiple projects"),(0,n.kt)("p",{parentName:"li"},"This promotes sharing and code reuse, and is highly recommended.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Separate repositories for large binary files"),(0,n.kt)("p",{parentName:"li"},"Git doesn\u2019t handle large binary files ideally yet and large repositories can be slow. If you must commit them, separating them out into their own repository can make things more efficient.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Separate repositories for planned continual history rewrites"),(0,n.kt)("p",{parentName:"li"},"You will note that I have already recommended against rewriting public history. Well, there are times when doing that just makes sense. One example might be a cache of pre-built binaries so that most people don\u2019t need to rebuild them. Yet older versions of this cache (or at least older versions not at tag boundaries) may be entirely useless and so you want to pretend they never happened to save space. You can rebase, filter, or squash these unwanted commits away, but this is rewriting history and can cause problem. So if you really must do so, isolate these files into a repository so that at least everything else will not be affected.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Group concepts into a superproject"),(0,n.kt)("p",{parentName:"li"},"Once you have divided, now you need to conquer. You can assemble multiple individual repositories into a superproject to group all of the concepts together to create your unified work."),(0,n.kt)("p",{parentName:"li"},"There are two main methods of doing this."),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"git-submodules")),(0,n.kt)("p",{parentName:"li"},"Git submodules is the native git approach, which provides a strong binding between the superproject repository and the subproject repositories for every commit. This leads to a baroque and annoying process for updating the subproject. However, if you do not control the subproject (solvable by \u201cforking\u201d) or like to perform blame-based history archeology where you want to find out the absolute correspondence between the different projects at every commit, it is very useful.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"gitslave")),(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"http://gitslave.sf.net"},"gitslave")," is a useful tool to add a subsidiary git repositories to a git superproject when you control and develop on the subprojects at more or less the same time as the superproject, and furthermore when you typically want to tag, branch, push, pull, etc all repositories at the same time. There is no strict correspondence between superproject and subproject repositories except at tag boundaries (though if you need to look back into history you can usually guess pretty well and in any case this is rarely needed)."))))),(0,n.kt)("h2",{id:"do-make-useful-commit-messages"},"Do make useful commit messages"),(0,n.kt)("p",null,"Creating insightful and descriptive commit messages is one of the best things you can do for others who use the repository. It lets people quickly understand changes without having to read code. When doing history archeology to answer some question, good commit messages likewise become very important."),(0,n.kt)("p",null,"The normal git rule of using the first line to provide a short (50-72 character) summary of the change is also very good. Looking at the output of ",(0,n.kt)("inlineCode",{parentName:"p"},"gitk")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"git log --oneline")," might help you understand why."),(0,n.kt)("p",null,"Also see ",(0,n.kt)("a",{parentName:"p",href:"http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html"},"A Note About Git Commit Messages")," for even more good ideas."),(0,n.kt)("p",null,"While this relates to the later topic of ",(0,n.kt)("a",{parentName:"p",href:"#do-integrate-with-external-tools"},"integration with external tools"),", including bug/issue/request tracking numbers in your commit messages provides a great deal of associated information to people trying to understand what is going on. You should also enforce your standards on commit messages, when possible, through hooks. See ",(0,n.kt)("a",{parentName:"p",href:"#do-enforce-standards"},"Enforcing standards")," below."),(0,n.kt)("h2",{id:"on-sausage-making"},"On Sausage Making"),(0,n.kt)("p",null,"Some people like to hide the sausage making ",(0,n.kt)("a",{parentName:"p",href:"#footnotes"},"\xb9"),", or in other words pretend to the outside world that their commits sprung full-formed in utter perfection into their git repository. Certain large public projects demand this, others demand smushing all work into one large commit, and still others do not care."),(0,n.kt)("p",null,"A good reason to hide the sausage making is if you feel you may be cherry-picking commits a lot (though this too is often a sign of bad workflow). Having one or a small number of commits to pick is much easier than having to find one commit here, one there, and half of this other one. The latter approach makes your problem much much harder and typically will lead to merge conflicts when the donor branch is finally merged in."),(0,n.kt)("p",null,"Another good reason is to ensure each commit compiles and/or passes regression tests, and represents a different easily understood concepts. The former allows ",(0,n.kt)("inlineCode",{parentName:"p"},"git-bisect")," to choose any commit and have a good chance of that commit doing something useful, and the latter allows for easy change/commit/code review, understanding, archeology, and cherry-picking. When reviewing commits, for example the reviewer might see something suspicious in a commit and then have to spend time tracking down their suspicions and write them up, only to discover five commits later that the original developer subsequently found and fixed the problem, wasting the reviewer\u2019s time (reviewing the entire patch series as a diff fixes this problem but greatly adds complexity as multiple concepts get muddled). By cleaning up patches into single, logical changes that build on one another, and which don\u2019t individually regress (i.e., they are always moving towards some desirable common endpoint), the author is writing a chronological story not of what happened, but what ",(0,n.kt)("em",{parentName:"p"},"should")," happen, with the intent that the audience (i.e., reviewers) are convinced that the change is the right thing to do. Proponents claim it is all about leaving a history others can later use to understand ",(0,n.kt)("em",{parentName:"p"},"why")," the code became the way it is now, to make it less likely for others to break it."),(0,n.kt)("p",null,"The downside to ",(0,n.kt)("em",{parentName:"p"},"hiding the sausage")," making is the added time it takes to perfect the administrative parts of the developers job. It is time taken away from getting code working; time solely dedicated to either administrative beauty or enhancing the ability to perform the blame-based (or ego-full) development methodology."),(0,n.kt)("p",null,"If you think about it, movies are made this way. Scenes are shot out of temporal order, multiple times, and different bits are picked from this camera and that camera. Without examining the analogy too closely, this is similar to how different git commits might be viewed. Once you have everything in the \u201ccan\u201d (repository) you go back and in post-production, you edit and splice everything together to form individual cuts and scenes, sometimes perhaps even doing some digital editing of the resulting product."),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"git rebase -i"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"git add -p"),", and ",(0,n.kt)("inlineCode",{parentName:"p"},"git reset -p")," can fix commits up in post-production by splitting different concepts, merging fixes to older commits, etc. See ",(0,n.kt)("a",{parentName:"p",href:"http://sethrobertson.github.com/GitPostProduction/"},"Post-Production Editing using Git")," also ",(0,n.kt)("a",{parentName:"p",href:"http://repo.or.cz/w/topgit.git"},"TopGit")," and ",(0,n.kt)("a",{parentName:"p",href:"https://stacked-git.github.io/"},"StGit"),"."),(0,n.kt)("p",null,"Be sure you do all of this work ",(0,n.kt)("em",{parentName:"p"},"before")," doing any non-squashed merges (not rebases: merges) and ",(0,n.kt)("em",{parentName:"p"},"before")," pushing. Your work becomes much more complex and/or impossible afterwards."),(0,n.kt)("h4",{id:"footnotes"},"Footnotes:"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"#"},"\xb9")," The process of developing software, similar to the process of making sausage, is a messy messy business ",(0,n.kt)("a",{parentName:"p",href:"#footnotes"},"\xb2")," all sorts of stuff happens in the process of developing software. Bugs are inserted into the code, uncovered, patched over. The end result may be a tasty program, but anyone looking at the process of how it was created (through inspection of the commits) may end up with a sour taste in their mouth. If you hide the sausage making, you can create a beautiful looking history where each step looks as delicious as the end-product. ",(0,n.kt)("a",{href:"#on-sausage-making"},"Back to footnote reference")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"#"},"\xb2")," If you do not understand why someone would want to hide the sausage making, and you enjoy eating sausage, never, ever, watch sausages being made, read ",(0,n.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/The_Jungle"},"\u201cThe Jungle\u201d"),", or otherwise try to expose yourself to any part of the sausage making process. You will lead a much tastier (and perhaps shorter) life in your blissful ignorance."),(0,n.kt)("h2",{id:"do-keep-up-to-date"},"Do keep up to date"),(0,n.kt)("p",null,"This section has some overlap with workflow. Exactly how and when you update your branches and repositories is very much associated with the desired workflow. Also I will note that not everyone agrees with these ideas (but they should!)"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Pulling with ",(0,n.kt)("inlineCode",{parentName:"p"},"--rebase")),(0,n.kt)("p",{parentName:"li"},"Whenever I pull, under most circumstances I ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull --rebase"),". This is because I like to see a linear history (my commit came after all commits that were pushed before it, instead of being developed in parallel). It makes history visualization much simpler and ",(0,n.kt)("inlineCode",{parentName:"p"},"git bisect")," easier to see and understand."),(0,n.kt)("p",{parentName:"li"},"A specific circumstance in which you should avoid using ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull --rebase")," is if you merged since your last push. You might want to ",(0,n.kt)("inlineCode",{parentName:"p"},"git fetch; git rebase -p @{u}")," (and check to make sure the merge was recreated properly) or do a normal merge in that circumstance."),(0,n.kt)("p",{parentName:"li"},"Another specific circumstance is if you are pulling from a non-authoritative repository which is not fully up to date with respect to your authoritative upstream. A rebase in this circumstance could cause the published history to be rewritten, ",(0,n.kt)("a",{parentName:"p",href:"#dont-change-published-history"},"which would be bad"),"."),(0,n.kt)("p",{parentName:"li"},"Some people argue against this because the non-final commits may lose whatever testing those non-final commits might have had since the deltas would be applied to a new base. This in turn might make git-bisect\u2019s job harder since some commits might refer to broken trees, but really this is only relevant to people who want to hide the sausage making. Of course to ",(0,n.kt)("em",{parentName:"p"},"really")," hide the sausage making you should still rebase and then test each intermediate commit to ensure it compiles and passes your regression tests (you do have regression tests, don\u2019t you?) so that a future bisector will have some strong hope that the commit will be usable. After all, that future bisector might be you."),(0,n.kt)("p",{parentName:"li"},"Other people argue against this (especially in highly decentralized environments) because doing a merge explicitly records who performed the merge, which provides someone to blame for inadequate testing if two histories were not combined properly (as opposed to the hidden history with implicit blame of rebase)."),(0,n.kt)("p",{parentName:"li"},"Still others argue that you are unable to automatically discover when someone else has ",(0,n.kt)("a",{parentName:"p",href:"#dont-change-published-history"},"rewritten public history")," if you use ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull --rebase")," normally, so someone might have hidden something malicious in an older (presumably already reviewed) commit. If this is of concern, you can still use rebase, but you would have to ",(0,n.kt)("inlineCode",{parentName:"p"},"git fetch")," first and look for \u201cforced update\u201d in that output or in the reflog for the remote branches."),(0,n.kt)("p",{parentName:"li"},"You can make this the default with the ",(0,n.kt)("inlineCode",{parentName:"p"},"branch.<name>.rebase")," configuration option (and more practically, by the \u201cbranch.autosetuprebase\u201d configuration option). See ",(0,n.kt)("a",{parentName:"p",href:"http://jk.gs/git-config.html"},"man git-config"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Rebasing (when possible)"),(0,n.kt)("p",{parentName:"li"},"Whenever I have a private branch that I want to update, I use rebase (for the same reasons as above). History is clean and simple. However, if you share this branch with other people, rebasing is rewriting public history and should/must be avoided. You may only rebase commits that no-one else has seen (which is why ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull --rebase")," is safe).")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Merging without speeding"),(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"git merge")," has the concept of fast-forwarding, or realizing that the code you are trying to merge in is identical to the result of the code after the merge. Thus instead of doing work, creating new commits, etc, git simply changes the branch pointers (fast forwards them) and calls it good."),(0,n.kt)("p",{parentName:"li"},"This is good when doing ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull")," but not so good when doing ",(0,n.kt)("inlineCode",{parentName:"p"},"git merge")," with a non-@{u} (upstream) branch. The reason this is not good is because it loses information. Specifically it loses track of which branch is the first parent and which is not. If you don\u2019t ever want to look back into history, then it does not matter. However, if you want to know the branch on which a commit was originally made, using fast-forward makes that question impossible to answer. If you try, git will pick one branch or the other (the first parent or second parent) as the one on which both branches\u2019 activities were performed and the other (original) parent\u2019s branch will be anonymous. There are typically worse things in the world, but you lose information that is not recoverable in any other way by a repository observer and in my book that is bad. Use ",(0,n.kt)("inlineCode",{parentName:"p"},"git merge --no-ff")," instead."))),(0,n.kt)("h2",{id:"do-periodic-maintenance"},"Do periodic maintenance"),(0,n.kt)("p",null,"The first two items should be run on your server repositories as well as your user repositories."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Validate your repo is sane (",(0,n.kt)("inlineCode",{parentName:"p"},"git fsck"),")"),(0,n.kt)("p",{parentName:"li"},"You need not check dangling objects unless you are missing something")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Compact your repo (",(0,n.kt)("inlineCode",{parentName:"p"},"git gc")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"git gc --aggressive"),")"),(0,n.kt)("p",{parentName:"li"},"This will removed outdated dangling objects (after the two+ week grace period). It will also compress any loose objects git has added since your last gc. git will run a minimal gc automatically after certain commands, but doing a manual gc often (and \u201c\u2013aggressive\u201d every few hundred changesets) will save space and speed git operations.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Prune your remote tracking branches (",(0,n.kt)("inlineCode",{parentName:"p"},"git remote update --prune"),")"),(0,n.kt)("p",{parentName:"li"},"This will get rid of any branches that were deleted upstream since you cloned/pruned. It normally isn\u2019t a major problem one way or another, but it might lead to confusion.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Check your stash for forgotten work (",(0,n.kt)("inlineCode",{parentName:"p"},"git stash list"),")"),(0,n.kt)("p",{parentName:"li"},"If you don\u2019t do it very often, the context for the stashed work will be forgotten when you finally do stumble on it, creating confusion."))),(0,n.kt)("h2",{id:"do-enforce-standards"},"Do enforce standards"),(0,n.kt)("p",null,"Having standards is a best practice and will improve the quality of your commits, code-base, and probably enhance git-bisect and archeology functionality, but what is the use of a standard if people ignore them? Checks could involve regression tests, compilation tests, syntax/lint checkers, commit message analysis, etc. Of course, there are times when standards get in the way of doing work, so provide some method to temporarily disable the checks when appropriate."),(0,n.kt)("p",null,"Traditionally, and in some people\u2019s views ideally, you would enforce the checks on the client side in a pre-commit hook (perhaps have a directory of standard hooks in your repo and might ask users to install them) but since users will often not install said hooks, you also need to enforce the standards on the server side. Additionally, if you follow the commit-early-and-often-and-perfect-it-later philosophy that is promoted in this document, initial commits may ",(0,n.kt)("em",{parentName:"p"},"not")," satisfy the hooks."),(0,n.kt)("p",null,"Enforcing standards in a update hook on the server allows you to reject commits that don\u2019t follow the standards. You can also chide the user for not using the standard client-side hook to begin with (if you recommend that approach)."),(0,n.kt)("p",null,"See ",(0,n.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20171023223424/https://puppet.com/blog/git-workflow-and-puppet-environments"},"Puppet Version Control")," for an example for a \u201cGit Update Hook\u201d and \u201cGit Pre-Commit Hook\u201d and ",(0,n.kt)("a",{parentName:"p",href:"https://puppet.com/blog/how-to-use-git-commit-hooks-puppet-enterprise/"},"\u201cGit Commit hook\u201d")," that enforces certain standards. Note that the update hook is examining files individually instead of providing whole-repository testing. Whether individual files can be tested in isolation for your standards or whether you need the whole repository (for instance, any language where one file can reference or include another might need whole repository checks) is of course a personal choice. The referenced examples are useful for ideas, anyway."),(0,n.kt)("h2",{id:"do-use-useful-tools"},"Do use useful tools"),(0,n.kt)("p",null,"More than useful, use of these tools may help you form a best practice!"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/sitaramc/gitolite"},"gitolite")),(0,n.kt)("p",{parentName:"li"},"We already mentioned gitolite above, but it forms a great git server intermediary for access control.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"http://gitslave.sf.net"},"gitslave")),(0,n.kt)("p",{parentName:"li"},"We already mentioned gitslave above, but it forms a great alternative to git-submodules when forming superprojects out of repositories you control.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"http://code.google.com/p/gerrit/"},"gerrit")),(0,n.kt)("p",{parentName:"li"},"To quote the website: Gerrit is a web based code review system, facilitating online code reviews for projects using the Git version control system."))),(0,n.kt)("h2",{id:"do-integrate-with-external-tools"},"Do integrate with external tools"),(0,n.kt)("p",null,"Increasing communication and decreasing friction and roadblocks to your developer\u2019s work will have many advantages. If you make something easy, convenient, and useful to do, people might just well do it."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Web views"),(0,n.kt)("p",{parentName:"li"},"This is pretty standard stuff, but still a best practice. Setting up a tool like ",(0,n.kt)("a",{parentName:"p",href:"http://jk.gs/gitweb.html"},"gitweb")," (or ",(0,n.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20130914063137/http://hjemli.net/git/cgit/"},"cgit")," or whatever) to allow URL reference to commits (among other visualization interfaces it provides) gives people a great way to refer to commits in email and conversations. If someone can click on a link vs having to fire up git and pull down the latest changes and start up some visualization tool they are much more likely to help you.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Bug tracking"),(0,n.kt)("p",{parentName:"li"},"Industry best practice suggests that you should have a bug tracking system. Hopefully you do. Well, I\u2019m here to tell you that integrating your bug tracking system with git makes the two systems one thousand times more effective. Specifically, come up with a standard for tagging commits with bug numbers (eg. \u201cBug 1234: Adjust the frobnoz down by .5\u201d) and then have a receive hook on the upstream repo that automatically appends that commit information to the ticket. If you really love your developers, develop syntax that lets them close the ticket as part of the commit message (eg. \u201cBug 1235r: Adjust the frobnoz up by .25\u201d)."),(0,n.kt)("p",{parentName:"li"},"While it probably will be a side-effect of the git integration, ensuring that your ticketing system has an email interface for ticket creation and so that replies to ticket email get stored in the ticket are all very important for making a ticketing system useful and convenient to use."),(0,n.kt)("p",{parentName:"li"},"The easier a system is for people to use, the more likely they will use it. Being able to see the context in which a commit was made (or conversely, being able to find the commit that solved a problem) is incredibly useful. When you send out your commit announcements, make sure to hyperlink the bug tracker in the commit message, and likewise in the tracker message, hyperlink to the web view of the commit."),(0,n.kt)("p",{parentName:"li"},"Notes: some commits can apply to multiple bugs. Generate a standard and code to handle this standard. Also, if you do hours tracking, you may want a syntax to handle that. (eg. \u201cBug 12346w/5: Bug 12347rw/3: Adjust the frobnoz up by .3\u201d)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"IRC/chat rooms/bots"),(0,n.kt)("p",{parentName:"li"},"Having an IRC server with some standard channels to discuss issues and problems provides a great benefit both tactically and strategically (it helps teach both the questioner and the answerer). Adding a robot in those chat room to provide assistance adds significant value. When someone talks about Bug 1234, the bot can provide a hyperlink to that ticket. When someone pushes some commits or adds a bug, it could announce those facts. All sorts of things are possible (RFC lookups, MAC vendor lookups, Eliza psychoanalysis, etc) but there is a fine line between usefulness and overwhelming noise."),(0,n.kt)("p",{parentName:"li"},"If you use github, github provides an \u201cIRC\u201d \u201cService Hook\u201d that lets you get git announcements for free. Said robot will not provide any additional value added services you might want. ",(0,n.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20110827172758/http://cia.vc/"},"CIA")," is another packaged commit announcement system and of course many IRC robot frameworks can be found with simple web searches.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Wikis"),(0,n.kt)("p",{parentName:"li"},"Having convenient syntax to link to bugs in your bug tracking system and branches/tags/commits in your gitweb again makes all three systems more useful. Increased synergy through integration!")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Other services"),(0,n.kt)("p",{parentName:"li"},"While I have your attention, there are a few other services which you should probably bring up as a best practice for your organization (but which have only limited applicability to git):"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Pastebin-like private text paste service"),(0,n.kt)("p",{parentName:"li"},"The free internet pastebin services are great and very useful, but you cannot paste proprietary information into them. So bring one of those services up yourself. Ensure that you have a portable application interface to this service to reduce friction (",(0,n.kt)("inlineCode",{parentName:"p"},"git status | mypastebin"),").")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Imagebin-like private image paste service"),(0,n.kt)("p",{parentName:"li"},"Likewise, bringing up a image paste service and associated client has the same justification and the same benefit. While the obvious use is for screenshots, other uses will become apparent. Just do it.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"URL shortener"),(0,n.kt)("p",{parentName:"li"},"The justification for a URL shortener is a little weaker than text/image paste services, but it still exists. Since it is a trivial service, you might as well bring it up for proprietary URLs.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Search"),(0,n.kt)("p",{parentName:"li"},"Providing a search service for both the web services you provide, but also for git repositories and any other collections of documents or data you might have lying around will save your users hours of searching. Don\u2019t forget to enable locate (for Unix/Linux systems) while you are at it.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Mailing lists"),(0,n.kt)("p",{parentName:"li"},"Creating mailing lists with searchable archives for users to communicate improves transparency and information flow. Ideally in many cases the mailing lists should be self-service and have digest options. Of course git commits, and bug announcements, and bug updates should all go to such mailing lists.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Role aliases"),(0,n.kt)("p",{parentName:"li"},"Instead of saying, send mail to Bob for your sales questions and Alice for your IT problems, you should have well defined and findable role aliases so that vacations, personnel changes, and related issues do not have to affect people\u2019s communication behaviors. Of course, in many cases, you may want to have these roles feed into your ticketing system for tracking instead of depending on human management of private mail queues.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"VNC-sharing of server consoles"),(0,n.kt)("p",{parentName:"li"},"When you have servers (machines without humans in front of them all of the time), make sure that the console is available virtually. Getting a bog-standard KVM to mediate access to the consoles is good, but what you really need to do is get a VNC enabled KVM or passthrough device (like the AdderLink IPEPS and friends) attached to the KVM so that you can have remote access to the servers. Why VNC and not remote desktop or some java console? Portability and flexibility. If you need multiple users having simultaneous access to the servers, you can get a multi-console multi-server KVM. Remember, if you have to get up out of your seat, you have failed."),(0,n.kt)("p",{parentName:"li"},"Having a VNC console access allows users to more easily consult with each other on problems.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"VMs (with VNC sharing) for most services"),(0,n.kt)("p",{parentName:"li"},"Instead of having dedicated hardware, create VMs for your critical services. The VM images then can be more easily backed up, moved around, and have less wasted resources. Of course, don\u2019t forget the admonition to have a portable multiuser console system like VNC for console access. Personally, I use KVM-QEMU for my virtualization needs. It is free and works great."),(0,n.kt)("p",{parentName:"li"},"Having a VNC console access allows users to more easily consult with each other on problems.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Audio conference"),(0,n.kt)("p",{parentName:"li"},"An audio conferencing service provides another low-friction method of increasing communication, which speeds development. My sources tell me you can get a plugin for asterisk that will give you free conference services. Since you are of course using VOIP for your communication, you then should have essentially free internal conferencing."))))),(0,n.kt)("h2",{id:"miscellaneous-dos"},"Miscellaneous \u201cDo\u201ds"),(0,n.kt)("p",null,"These are random best practices that are too minor or disconnected to go in any other section."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Copy/move a file in a different commit from any changes to it"),(0,n.kt)("p",{parentName:"li"},"If you care about git properly displaying the fact that you moved a file, you should copy or move the file in a different commit from any changes you need to immediately make to that file. This is because git does not record ",(0,n.kt)("inlineCode",{parentName:"p"},"git mv")," any different from a delete and an add, and because ",(0,n.kt)("inlineCode",{parentName:"p"},"git cp")," doesn\u2019t even exist. Git\u2019s output commands are the ones that interpret the data as a move or copy. See the -C and -M options to ",(0,n.kt)("inlineCode",{parentName:"p"},"git log")," (and similar commands).")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"(Almost) Always name your stashes"),(0,n.kt)("p",{parentName:"li"},"If you don\u2019t provide a name when stashing, git generates one automatically based on the previous commit. While this tells you the branch where a stash was made, it gives you no idea what is in it. Unless you plan to pop a stash in the next few minutes, you should always give it a name with ",(0,n.kt)("inlineCode",{parentName:"p"},"git stash save XXX")," rather than the shorter default ",(0,n.kt)("inlineCode",{parentName:"p"},"git stash")," (which should be reserved for very temporary uses). This way you\u2019ll have some idea what a stash is about when you are looking at it months later.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Protect your bare/server repos against history rewriting"),(0,n.kt)("p",{parentName:"li"},"If you initialize a bare git repository with \u201c\u2013shared\u201d it will automatically get the git-config \u201creceive.denyNonFastForwards\u201d set to true. You should ensure that this is set just in case you did something weird during initialization. Furthermore, you should also set \u201creceive.denyDeletes\u201d so that people who are trying to rewrite history cannot simply delete the branch and then recreate it. Best practice is for there to be a speedbump any time someone is trying to delete or rewrite history, since it is such a bad idea.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Experiment!"),(0,n.kt)("p",{parentName:"li"},"When you have an idea or are not sure what something does, try it out! Ideally try it out in a clone or copy so that recovery is trivial. While you can normally completely recover from any git experiment involving data that has been fully committed, perhaps you have not committed yet or perhaps you are not sure whether something falls in the category of \u201ctrying hard\u201d to destroy history."))),(0,n.kt)("h2",{id:"miscellaneous-donts"},"Miscellaneous \u201cdon\u2019t\u201ds"),(0,n.kt)("p",null,"In this list of things to ",(0,n.kt)("em",{parentName:"p"},"not")," do, it is important to remember that there are legitimate reasons to do all of these. However, you should not attempt any of these things without understanding the potential negative effects of each and why they might be in a best practices \u201cDon\u2019t\u201d list."),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"DO NOT")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"commit anything that can be regenerated from other things that were committed."),(0,n.kt)("p",{parentName:"li"},"Things that can be regenerated include binaries, object files, jars, ",(0,n.kt)("inlineCode",{parentName:"p"},".class"),", flex/yacc generated code, etc. Really the only place there is room for disagreement about this is if something might take hours to regenerate (rendered images, e.g., but see ",(0,n.kt)("a",{parentName:"p",href:"#do-divide-work-into-repositories"},"Dividing work into repositories")," for more best practices about this) or autoconf generated files (so people can configure and compile without autotools installed).")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"commit configuration files"),(0,n.kt)("p",{parentName:"li"},"Specifically configuration files that might change from environment to environment or for any reasons. See ",(0,n.kt)("a",{parentName:"p",href:"https://gist.github.com/1423106"},"Information about local versions of configuration files"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use git as a web deployment tool"),(0,n.kt)("p",{parentName:"li"},"Yes it can be done in a sufficiently simple/non-critical environment with something like ",(0,n.kt)("a",{parentName:"p",href:"http://toroid.org/ams/git-website-howto"},"Abhijit Menon-Sen\u2019s document on using git to manage a web site")," to help, though there are ",(0,n.kt)("a",{parentName:"p",href:"https://gist.github.com/1714235"},"other")," ",(0,n.kt)("a",{parentName:"p",href:"http://joemaller.com/990/a-web-focused-git-workflow/"},"examples"),". However, this does not give you atomic updates, synchronized db updates, or other accouterments of an industrial deployment system.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"commit large binary files (when possible)"),(0,n.kt)("p",{parentName:"li"},"Large is currently relative to the amount of free RAM you have. Remember that not everyone may be using the same memory configuration you are. Support for large files is an active git topic, so watch for changes."),(0,n.kt)("p",{parentName:"li"},"After running a ",(0,n.kt)("inlineCode",{parentName:"p"},"git gc")," you should be able to find the largest objects by running:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"git verify-pack -v .git/objects/pack/pack-*.idx |\ngrep blob | sort -k3nr | head |\nwhile read s x b x; do\n  git rev-list --all --objects | grep $s |\n  awk '{print \"'\"$b\"'\",$0;}';\ndone \n")),(0,n.kt)("p",{parentName:"li"},"Consider using ",(0,n.kt)("a",{parentName:"p",href:"http://git-annex.branchable.com/"},"Git annex")," or ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/alebedev/git-media"},"Git media")," if you plan on having large binary files and your workflow allows.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"create very large repositories (when possible)"),(0,n.kt)("p",{parentName:"li"},"Git can be slow in the face of large repositories. The definition of \u201clarge\u201d will depend on your RAM size, I/O speed, expectations, etc. However, having 100K-200K files in a repository may slow common operations due to stat system call speeds (especially on Windows) and having many large (esp. binary) files (see above) can slow many operations."),(0,n.kt)("p",{parentName:"li"},"If you start having pack files (in ",(0,n.kt)("inlineCode",{parentName:"p"},".git/objects/pack"),") which are larger than 1GB, you might also want to consider creating a ",(0,n.kt)("inlineCode",{parentName:"p"},".keep")," file (right beside the ",(0,n.kt)("inlineCode",{parentName:"p"},".idx")," and ",(0,n.kt)("inlineCode",{parentName:"p"},".pack")," files) for a large pack which will prevent them from being repacked during gc and repack operations."),(0,n.kt)("p",{parentName:"li"},"If you find yourself running into memory pressure when you are packing commits (usually ",(0,n.kt)("inlineCode",{parentName:"p"},"git gc [--aggressive]"),"), there are git-config options that can help. ",(0,n.kt)("inlineCode",{parentName:"p"},"pack.threads=1")," ",(0,n.kt)("inlineCode",{parentName:"p"},"pack.deltaCacheSize=1")," ",(0,n.kt)("inlineCode",{parentName:"p"},"pack.windowMemory=512m")," all of which trade memory for CPU time. Other likely ones exist. My gut tells me that sizing (\u201cdeltaCacheSize\u201d + \u201cwindowMemory\u201d + min(\u201ccore.bigFileThreshold","[","512m","]","\u201d, TheSizeOfTheLargestObject)) * \u201cthreads\u201d to be around ",(0,n.kt)("em",{parentName:"p"},"half")," the amount of RAM you can dedicate to running ",(0,n.kt)("inlineCode",{parentName:"p"},"git gc")," will optimize your packing experience, but I will be the first to admit that made up that formula based on a very few samples and it could be drastically wrong."),(0,n.kt)("p",{parentName:"li"},"Support for large repositories is an active git topic, so watch for changes.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"reset")," (",(0,n.kt)("inlineCode",{parentName:"p"},"--hard | --merge"),") without committing/stashing"),(0,n.kt)("p",{parentName:"li"},"This can often overwrite the working directory without hope of recourse.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"checkout")," in file mode"),(0,n.kt)("p",{parentName:"li"},"This will overwrite some (or potentially all with ",(0,n.kt)("inlineCode",{parentName:"p"},"."),") of the working directory without hope of recourse.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"git clean")," without previously running with \u201c",(0,n.kt)("inlineCode",{parentName:"p"},"-n"),"\u201d first"),(0,n.kt)("p",{parentName:"li"},"This will delete untracked files without hope of recourse.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"prune the reflog"),(0,n.kt)("p",{parentName:"li"},"This is removing your safety belt.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"expire \u201cnow\u201d"),(0,n.kt)("p",{parentName:"li"},"This is cutting your safety belt.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"git repack -ad")),(0,n.kt)("p",{parentName:"li"},"Unreferenced objects in a newly redundant pack will get deleted which cuts your safety belt. Instead use ",(0,n.kt)("inlineCode",{parentName:"p"},"git gc")," or at least ",(0,n.kt)("inlineCode",{parentName:"p"},"git repack -Ad"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use a branch argument to ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"git fetch")),(0,n.kt)("p",{parentName:"li"},"No doubt there is a good use case for, say, ",(0,n.kt)("inlineCode",{parentName:"p"},"git pull origin master")," or whatever, but I have yet to understand it. What I ",(0,n.kt)("em",{parentName:"p"},"do")," understand is that every time I have seen someone use it, it has ended in tears.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use git as a generic filesystem backup tool"),(0,n.kt)("p",{parentName:"li"},"Git was not written as a dedicated backup tool, and such tools do exist. Yes people have done it successfully, but usually with lots of scripts or modifications around it. One successful example of integration/modifications is ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/bup/bup"},"bup"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"rewrite public history"),(0,n.kt)("p",{parentName:"li"},"See ",(0,n.kt)("a",{parentName:"p",href:"#dont-change-published-history"},"section about this topic"),". It bears repeating, though.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"change where a tag points"),(0,n.kt)("p",{parentName:"li"},"This is another way to ",(0,n.kt)("a",{parentName:"p",href:"#dont-change-published-history"},"rewrite public history"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"git-filter-branch")),(0,n.kt)("p",{parentName:"li"},"Still another way to ",(0,n.kt)("a",{parentName:"p",href:"#dont-change-published-history"},"rewrite public history"),"."),(0,n.kt)("p",{parentName:"li"},"However, if you are going to use git-filter-branch, make sure you end your command with ",(0,n.kt)("inlineCode",{parentName:"p"}," \u2013tag-name-filter cat \u2013 \u2013all")," unless you are really really sure you know what you are doing.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"create ",(0,n.kt)("inlineCode",{parentName:"p"},"--orphan")," branches"),(0,n.kt)("p",{parentName:"li"},"With the notable exception of gh-pages (which is a hack github uses for convenience, not an expression of general good style practice), any situation where creating an orphan branch seems like a reasonable solution you probably should just create a new repository. If the new branch cannot really be thought of as being related to the other branches in your repository so that merging between the two really has any conceptual relevance, then the concept is probably far enough apart to warrant its own repository.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"clone --shared")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"--reference")),(0,n.kt)("p",{parentName:"li"},"This can lead to problems for non-normal git actions, or if the other repository is deleted/moved. See ",(0,n.kt)("a",{parentName:"p",href:"http://jk.gs/gitworkflows.html"},"git-clone manual page"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"git-grafts")),(0,n.kt)("p",{parentName:"li"},"This is deprecated in favor of ",(0,n.kt)("inlineCode",{parentName:"p"},"git-replace"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"use ",(0,n.kt)("inlineCode",{parentName:"p"},"git-replace")),(0,n.kt)("p",{parentName:"li"},"But don\u2019t use ",(0,n.kt)("inlineCode",{parentName:"p"},"git-replace")," either."))),(0,n.kt)("h2",{id:"disclaimer"},"Disclaimer"),(0,n.kt)("p",null,"Information is not promised or guaranteed to be correct, current, or complete, and may be out of date and may contain technical inaccuracies or typographical errors. Any reliance on this material is at your own risk. No one assumes any responsibility (and everyone expressly disclaims responsibility) for updates to keep information current or to ensure the accuracy or completeness of any posted information. Accordingly, you should confirm the accuracy and completeness of all posted information before making any decision related to any and all matters described."),(0,n.kt)("h2",{id:"copyright"},"Copyright"),(0,n.kt)("p",null,"Copyright \u24d2 2012 Seth Robertson"),(0,n.kt)("p",null,"Creative Commons Attribution-ShareAlike 3.0 Generic (CC BY-SA 3.0) ",(0,n.kt)("a",{parentName:"p",href:"http://creativecommons.org/licenses/by-sa/3.0/"},"http://creativecommons.org/licenses/by-sa/3.0/")),(0,n.kt)("p",null,"OR"),(0,n.kt)("p",null,"GNU Free Documentation v1.3 with no Invariant, Front, or Back Cover texts. ",(0,n.kt)("a",{parentName:"p",href:"http://www.gnu.org/licenses/fdl.html"},"http://www.gnu.org/licenses/fdl.html")),(0,n.kt)("p",null,"I would appreciate changes being sent back to me, being notified if this is used or highlighted in some special way, and links being maintained back to the ",(0,n.kt)("a",{parentName:"p",href:"http://sethrobertson.github.com/GitBestPractices/"},"authoritative source"),". Thanks."),(0,n.kt)("h2",{id:"thanks"},"Thanks"),(0,n.kt)("p",null,"Thanks to the experts on #git, and my co-workers, for review, feedback, and ideas."),(0,n.kt)("h2",{id:"comments"},"Comments"),(0,n.kt)("p",null,"Comments and improvements welcome."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/SethRobertson/GitBestPractices/issues"},"Use the github issue tracker")," or discuss with SethRobertson (and others) on ",(0,n.kt)("a",{parentName:"p",href:"irc://irc.freenode.net/git"},"#git")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"http://sethrobertson.github.io/"},"Other technical projects")))}c.isMDXComponent=!0}}]);