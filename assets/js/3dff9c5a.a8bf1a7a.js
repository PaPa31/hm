"use strict";(self.webpackChunkhuman_and_machine=self.webpackChunkhuman_and_machine||[]).push([[11277],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||o;return a?n.createElement(m,s(s({ref:t},d),{},{components:a})):n.createElement(m,s({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},68522:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const o={id:"4-07-updating-state-immutably",title:"4.07 Updating State Immutably",date:new Date("2021-03-29T23:32:07.000Z")},s=void 0,i={unversionedId:"react-complete-guide/04-lists-and-conditionals/Lessons/4-07-updating-state-immutably",id:"react-complete-guide/04-lists-and-conditionals/Lessons/4-07-updating-state-immutably",title:"4.07 Updating State Immutably",description:"The flaw of this approach is that in JavaScript, objects and arrays are reference types, so when I get persons from my state as I do here I actually get a pointer to the original person\u2019s object managed by React, to the original state I should say. If I then splice it here, I already mutate this original data and whilst it does work without throwing an error, this is not really how you should do it, this can lead to unpredictable apps and is definitely a bad practice.",source:"@site/courses/react-complete-guide/04-lists-and-conditionals/Lessons/4-07-updating-state-immutably.md",sourceDirName:"react-complete-guide/04-lists-and-conditionals/Lessons",slug:"/react-complete-guide/04-lists-and-conditionals/Lessons/4-07-updating-state-immutably",permalink:"/hm/courses/react-complete-guide/04-lists-and-conditionals/Lessons/4-07-updating-state-immutably",draft:!1,editUrl:"https://github.com/papa31/hm/edit/documentation/courses/react-complete-guide/04-lists-and-conditionals/Lessons/4-07-updating-state-immutably.md",tags:[],version:"current",lastUpdatedBy:"PaPa31",lastUpdatedAt:1631602446,formattedLastUpdatedAt:"Sep 14, 2021",frontMatter:{id:"4-07-updating-state-immutably",title:"4.07 Updating State Immutably",date:"2021-03-29T23:32:07.000Z"},sidebar:"Courses",previous:{title:"4.06 Lists And State",permalink:"/hm/courses/react-complete-guide/04-lists-and-conditionals/Lessons/4-06-lists-and-state"},next:{title:"4.08 Lists And Keys",permalink:"/hm/courses/react-complete-guide/04-lists-and-conditionals/Lessons/4-08-lists-and-keys"}},l={},p=[{value:"Good Practice",id:"good-practice",level:2},{value:"slice() method",id:"slice-method",level:3},{value:"spread operator <code>[...]</code>",id:"spread-operator-",level:3}],d={toc:p};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The flaw of this approach is that in JavaScript, objects and arrays are reference types, so when I get persons from my state as I do here I actually get a pointer to the original person\u2019s object managed by React, to the original state I should say. If I then ",(0,r.kt)("inlineCode",{parentName:"p"},"splice")," it here, I already ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," this original data and whilst it does work without throwing an error, this is not really how you should do it, this can lead to unpredictable apps and is definitely a bad practice."),(0,r.kt)("h2",{id:"good-practice"},"Good Practice"),(0,r.kt)("p",null,"You should always update state in an immutable fashion, so without mutating the original state first. Create a copy, change that and then update the state with that state."),(0,r.kt)("h3",{id:"slice-method"},"slice() method"),(0,r.kt)("p",null,"A good practice is to create a copy of your persons array before manipulating it and a simple way of doing this is by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"slice")," method. Slice without arguments simply copies the full array and returns a new one which is then stored here."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="App.js" {3}',title:'"App.js"',"{3}":!0},"...\n    deletePersonHandler = (personIndex) => {\n        const persons = this.state.persons.slice();\n        persons.splice(personIndex, 1);\n        this.setState({ persons: persons });\n    };\n...\n")),(0,r.kt)("p",null,"And you can now safely edit this new one and then update to react state with your new array."),(0,r.kt)("h3",{id:"spread-operator-"},"spread operator ",(0,r.kt)("inlineCode",{parentName:"h3"},"[...]")),(0,r.kt)("p",null,"An alternative to this approach would be to use it a ES6 feature, the ",(0,r.kt)("inlineCode",{parentName:"p"},"spread")," operator. It spreads out the elements in this array into a list of elements which simply then gets added to this array, so that now we have an array, a new array, with the objects from the old array but not the old array itself."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="App.js" {3}',title:'"App.js"',"{3}":!0},"...\n  deletePersonHandler = (personIndex) => {\n    const persons = [...this.state.persons];\n    persons.splice(personIndex, 1);\n    this.setState({ persons: persons });\n  };\n...\n")),(0,r.kt)("p",null,"So this is basically an equivalent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"slice")," approach, use whichever one you prefer, this is the more modern one, and you will see this ",(0,r.kt)("inlineCode",{parentName:"p"},"spread")," operator more often throughout the course."))}c.isMDXComponent=!0}}]);