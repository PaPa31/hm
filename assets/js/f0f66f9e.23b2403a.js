"use strict";(self.webpackChunkhuman_and_machine=self.webpackChunkhuman_and_machine||[]).push([[81349],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=l(n),d=o,h=m["".concat(p,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},62141:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return c},default:function(){return m}});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),s=["components"],i={id:"7-04-comparing-stateless-and-stateful-components",title:"7.04 Comparing Stateless And Stateful Components",date:new Date("2021-04-09T12:03:43.000Z")},p=void 0,l={unversionedId:"react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-04-comparing-stateless-and-stateful-components",id:"react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-04-comparing-stateless-and-stateful-components",title:"7.04 Comparing Stateless And Stateful Components",description:"Let me dive into that stateless versus stateful or presentational versus container component thing again.",source:"@site/courses/react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-04-comparing-stateless-and-stateful-components.md",sourceDirName:"react-complete-guide/07-diving-deeper-into-components-and-react-internals",slug:"/react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-04-comparing-stateless-and-stateful-components",permalink:"/hm/courses/react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-04-comparing-stateless-and-stateful-components",editUrl:"https://github.com/papa31/hm/edit/documentation/courses/react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-04-comparing-stateless-and-stateful-components.md",tags:[],version:"current",lastUpdatedBy:"PaPa31",lastUpdatedAt:1631602446,formattedLastUpdatedAt:"9/14/2021",frontMatter:{id:"7-04-comparing-stateless-and-stateful-components",title:"7.04 Comparing Stateless And Stateful Components",date:"2021-04-09T12:03:43.000Z"},sidebar:"Docs",previous:{title:"7.03 Splitting App Into Components",permalink:"/hm/courses/react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-03-splitting-app-into-components"},next:{title:"7.05 Class Based Vs Functional Components",permalink:"/hm/courses/react-complete-guide/07-diving-deeper-into-components-and-react-internals/7-05-class-based-vs-functional-components"}},c=[{value:"Stateful Comps",id:"stateful-comps",children:[],level:2},{value:"Stateless Comps",id:"stateless-comps",children:[],level:2}],u={toc:c};function m(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Let me dive into that ",(0,r.kt)("strong",{parentName:"p"},"stateless versus stateful")," or ",(0,r.kt)("strong",{parentName:"p"},"presentational versus container")," component thing again."),(0,r.kt)("h2",{id:"stateful-comps"},"Stateful Comps"),(0,r.kt)("p",null,"Now we're referring to ",(0,r.kt)("strong",{parentName:"p"},"stateful")," components when we're managing state in them, like we're doing in the ",(0,r.kt)("em",{parentName:"p"},"app.js"),". We got state here, and we're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," to change that state."),(0,r.kt)("p",null,"Now a functional component that manages its own state with the ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," would of course also be a stateful component, so stateful does not automatically mean class-based component."),(0,r.kt)("p",null,"Historically this has been the case, though. Because React hooks, like ",(0,r.kt)("strong",{parentName:"p"},"useState"),", are a really new feature. And therefore, you will still find plenty of applications, where ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," is only managed in class-based components."),(0,r.kt)("p",null,"Still since ",(0,r.kt)("inlineCode",{parentName:"p"},"React 16.8"),", ",(0,r.kt)("strong",{parentName:"p"},"stateful")," is not automatically a class-based component. It is a component that manages state, he that with state in a class or with the useState hook."),(0,r.kt)("h2",{id:"stateless-comps"},"Stateless Comps"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Presentational"),", also called ",(0,r.kt)("strong",{parentName:"p"},"dumb")," or ",(0,r.kt)("strong",{parentName:"p"},"stateless")," components historically have always been ",(0,r.kt)("inlineCode",{parentName:"p"},"functional components")," because prior to React 16.8, these functional components could not manage state."),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"React 16.8"),", functional components can also manage state with the useState hook but still, you want to have many presentational components in your app. And now what is a presentational component?"),(0,r.kt)("p",null,"It is a ",(0,r.kt)("strong",{parentName:"p"},"functional component that does not manage state"),". Even though you could with ",(0,r.kt)("inlineCode",{parentName:"p"},"useState"),", it is still a good practice to restrict yourself to a couple of components that are involved in the state management."),(0,r.kt)("p",null,"And of course, a couple depends on how big your app is. In big apps that can easily be hundreds of components, but the majority of your components should be presentational, stateless components, so functional components that don't manage state."),(0,r.kt)("p",null,"Now the question of course is why and the answer is: by splitting your app into ",(0,r.kt)("strong",{parentName:"p"},"container components"),", which is another term for these components, that manage the state in your app and the dumb presentational components."),(0,r.kt)("p",null,"By making that split, you keep your app manageable because you have a predictable flow of data, you know where your state changes, that will be in a couple of components and the other components are only there to render a nice user interface."),(0,r.kt)("p",null,"And they only define on external inputs, on props and that simply ensures that these components are highly predictable, that you can throw them anywhere into your application, and they work if you pass the right inputs in."),(0,r.kt)("p",null,"And as your application grows, you therefore have an easier time maintaining it. So having a lot of dumb or presentational components is a good idea."),(0,r.kt)("p",null,"Now of course, you definitely should not restrict yourself to one component only that does state management though. The more you work with React, the more you'll get a feeling for which component now should manage some state, so that its child components get the right inputs and which components would better be just presentational components."),(0,r.kt)("p",null,"But again as a rule, certainly think before you start managing state in a component, maybe you can do it in another component and keep that component you're working on a presentational one."),(0,r.kt)("p",null,"So that is how you should think about stateful and stateless or container and dumb or presentational components."),(0,r.kt)("p",null,"So what's the difference now, when should you use which?"))}m.isMDXComponent=!0}}]);